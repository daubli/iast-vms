package de.vms.vulnerability.service;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import javax.transaction.Transactional;

import org.springframework.stereotype.Service;

import de.vms.incident.model.Incident;
import de.vms.incident.model.IncidentType;
import de.vms.vulnerability.model.Severity;
import de.vms.vulnerability.model.Vulnerability;
import de.vms.vulnerability.model.VulnerabilityStatus;
import de.vms.vulnerability.model.VulnerabilityType;
import de.vms.vulnerability.persistence.VulnerabilityRepository;

@Service
public class VulnerabilityService {

    VulnerabilityRepository vulnerabilityRepository;

    public VulnerabilityService(VulnerabilityRepository vulnerabilityRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
    }

    public List<Vulnerability> getAllVulnerabilities() {
        return vulnerabilityRepository.findAll();
    }

    public List<Vulnerability> getAllOpenVulnerabilities() {
        return vulnerabilityRepository.getVulnerabilitiesByStatus(VulnerabilityStatus.OPEN);
    }

    public List<Vulnerability> getTenLatestOpenVulnerabilities() {
        return vulnerabilityRepository.findFirst10ByStatusEqualsOrderByLastDetectedDesc(VulnerabilityStatus.OPEN);
    }

    public Optional<Vulnerability> getVulnerabilityById(UUID vulnerabilityId) {
        return vulnerabilityRepository.findById(vulnerabilityId);
    }

    public Vulnerability getVulnerabilityByIncident(Incident incident) {
        return vulnerabilityRepository.getVulnerabilityByIncidentsContaining(incident);
    }

    @Transactional
    public void addIncidentToVulnerability(Vulnerability vulnerability, Incident incident) {
        vulnerability.addIncident(incident);
        vulnerabilityRepository.save(vulnerability);
    }

    @Transactional
    public void updateDuplicateVulnerability(Vulnerability vulnerability) {
        vulnerability.setStatus(VulnerabilityStatus.OPEN);
        vulnerability.setLastDetected(LocalDateTime.now(ZoneOffset.UTC));
        vulnerabilityRepository.save(vulnerability);
    }

    public void createNewVulnerabilityWithIncident(Incident incident) {
        Vulnerability vulnerability = new Vulnerability();
        LocalDateTime detectedTimestamp = LocalDateTime.now(ZoneOffset.UTC);
        vulnerability.setFirstDetected(detectedTimestamp);
        vulnerability.setLastDetected(detectedTimestamp);
        vulnerability.setStatus(VulnerabilityStatus.OPEN);
        vulnerability.addIncident(incident);

        if (incident.getIncidentType().equals(IncidentType.SQL_INJECTION)) {
            //improve this with a Description Builder
            String relevantPointInApplication = incident.getRelevantPointInApplication();
            if (relevantPointInApplication != null && relevantPointInApplication.contains("(")
                    && relevantPointInApplication.contains(")")) {
                String relevantClass = relevantPointInApplication.substring(relevantPointInApplication.indexOf("(") + 1,
                        relevantPointInApplication.indexOf(")"));
                vulnerability.setDescription("Found SQL Injection at " + relevantClass);
            } else {
                vulnerability.setDescription("Found SQL Injection");
            }
            vulnerability.setType(VulnerabilityType.SQLI);
            vulnerability.setSeverity(Severity.HIGH);
        } else if (incident.getIncidentType().equals(IncidentType.MISSING_CSRF_TOKEN)) {
            vulnerability.setDescription("Missing CSRF Token in Header");
            vulnerability.setType(VulnerabilityType.CSRF);
            vulnerability.setSeverity(Severity.MODERATE);
        }
        vulnerabilityRepository.save(vulnerability);
    }

    public Long getNumberOfVulnerabilitiesBySeverity(Severity severity) {
        return vulnerabilityRepository.countVulnerabilitiesBySeverityIs(severity);
    }

    public void deleteVulnerability(UUID id) {
        vulnerabilityRepository.deleteById(id);
    }

    @Transactional
    public Optional<Vulnerability> updateStatusOfVulnerability(UUID id, VulnerabilityStatus status) {
        Optional<Vulnerability> vulnerabilityOptional = Optional.ofNullable(vulnerabilityRepository.getOne(id));
        return vulnerabilityOptional.map(vulnerability -> {
            vulnerability.setStatus(status);
            return vulnerabilityRepository.save(vulnerability);
        });
    }
}
