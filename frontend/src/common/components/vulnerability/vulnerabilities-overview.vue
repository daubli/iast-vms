<template>
	<v-card elevation="2" :outlined="outlined">
		<v-card-title v-if="title">{{ title }}</v-card-title>
		<v-card-text v-if="allGreat">Great! Nothing found</v-card-text>
		<v-card-text v-else>
			<FilterByStatus v-if="!hideFilter" @filtersChangeFieldValue="handleChangeFieldValue" />
			<v-data-table
				v-bind="$attrs"
				:headers="headers"
				:items="tableItems"
				class="elevation-0"
				loading-text="Loading... Please wait"
				:loading="loading"
				no-data-text="This filtering applies to no vulnerability"
				@click:row="handleRowClick"
			>
				<template v-slot:item.status="{ item }">
					<v-icon>{{ bugStatusMapping[item.status] }}</v-icon>
				</template>

				<template v-slot:item.lastDetected="{ item }">
					{{ formatAsDate(item.lastDetected) }}
				</template>
				<template v-slot:item.severity="{ item }">
					<v-chip :color="severityColorMapping[item.severity]" dark
						>{{ capitalizeFirstLetter(item.severity) }}
					</v-chip>
				</template>
			</v-data-table>
		</v-card-text>
	</v-card>
</template>
<script lang="ts">
import Vue, { PropType } from 'vue';
import { Vulnerability, VulnerabilityStatus } from '@/domains/vulnerability/vulnerability.types';
import FilterByStatus from '@/common/components/vulnerability/filter/filter-by-status.vue';
import moment from 'moment';
import { mdiBug, mdiCheck, mdiShieldBugOutline } from '@mdi/js';

export default Vue.extend({
	name: 'VulnerabilitiesOverview',
	components: {
		FilterByStatus
	},
	props: {
		vulnerabilities: { type: Array as PropType<Vulnerability[]>, default: null },
		title: { type: String, default: '' },
		loading: { type: Boolean, default: true },
		outlined: { type: Boolean, default: false },
		hideFilter: { type: Boolean, default: false },
		hideStatusColumn: { type: Boolean, default: false }
	},
	data() {
		return {
			tableItems: [] as Vulnerability[],
			headers: [
				{
					text: '',
					value: 'status',
					width: '30px'
				},
				{
					text: 'Severity',
					value: 'severity',
					width: '100px'
				},
				{
					text: 'Type',
					value: 'type',
					width: '200px'
				},
				{
					text: 'Last Detected',
					value: 'lastDetected',
					width: '200px'
				},
				{
					text: 'Description',
					value: 'description',
					sortable: false
				}
			],
			severityColorMapping: {
				LOW: 'grey',
				MODERATE: 'orange',
				HIGH: 'red'
			},
			bugStatusMapping: {
				OPEN: mdiBug,
				INVALID: mdiShieldBugOutline,
				FIXED: mdiCheck
			}
		};
	},
	computed: {
		allGreat(): boolean {
			return this.vulnerabilities.length === 0;
		}
	},
	watch: {
		vulnerabilities: function() {
			this.tableItems = this.openVulnerabilities();
		}
	},
	mounted() {
		this.tableItems = this.openVulnerabilities();

		if (this.hideStatusColumn) {
			this.headers.shift();
		}
	},
	methods: {
		formatAsDate(item: string): string {
			return moment
				.utc(item)
				.local()
				.calendar();
		},
		capitalizeFirstLetter(word: string) {
			return word.charAt(0).toUpperCase() + word.slice(1);
		},
		handleRowClick(item: Vulnerability) {
			this.$router.push({ name: 'vulnerability-details', params: { vulnerabilityId: item.id } });
		},
		handleChangeFieldValue(data: Array<VulnerabilityStatus>) {
			this.tableItems = this.vulnerabilities.filter(item => data.indexOf(item.status) > -1);
		},
		openVulnerabilities() {
			return this.vulnerabilities.filter(item => item.status === VulnerabilityStatus.OPEN);
		}
	}
});
</script>
