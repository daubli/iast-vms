<template>
	<PageContent fullwidth>
		<PageHeader :title="title">
			<template slot="icon">
				<v-icon class="mr-3 d-inline" :color="iconColor" :size="30">{{ mdiBlur }}</v-icon>
			</template>
			<template slot="right">
				<v-tooltip v-if="!isFixed" bottom>
					<template v-slot:activator="{ on }">
						<div class="d-inline-block" v-on="on">
							<v-btn class="mr-1" outlined @click="markAsFixed">
								<v-icon>{{ mdiCheck }}</v-icon>
							</v-btn>
						</div>
					</template>
					<span>Fixed</span>
				</v-tooltip>
				<v-tooltip v-if="!isInvalid" bottom>
					<template v-slot:activator="{ on }">
						<div class="d-inline-block" v-on="on">
							<v-btn class="mr-1" outlined @click="markAsInvalid">
								<v-icon>{{ mdiShieldBugOutline }}</v-icon>
							</v-btn>
						</div>
					</template>
					<span>Mark as Invalid</span>
				</v-tooltip>
				<v-tooltip bottom>
					<template v-slot:activator="{ on }">
						<div class="d-inline-block" v-on="on">
							<v-btn class="mr-1" outlined @click="deleteVulnerability">
								<v-icon>{{ mdiTrashCan }}</v-icon>
							</v-btn>
						</div>
					</template>
					<span>Delete Vulnerability</span>
				</v-tooltip>
			</template>
		</PageHeader>
		<PageSection>
			<VulnerabilityInfo
				:severity="vulnerability.severity"
				:first-detected="vulnerability.firstDetected"
				:last-detected="vulnerability.lastDetected"
				:detected-on-agents="vulnerability.detectedOnAgents"
				:status="vulnerability.status"
			></VulnerabilityInfo>
			<HttpRequestInfo v-if="renderHttpInfoBox" :http-requests="httpRequests"></HttpRequestInfo>
			<DataFlowInfo v-if="isSqlInjection" :incidents="incidents"></DataFlowInfo>
			<StackTraceInfo v-if="!!stackTrace" :stack-trace="stackTrace"></StackTraceInfo>
		</PageSection>
	</PageContent>
</template>

<script lang="ts">
import Vue from 'vue';
import PageHeader from '@/common/components/layout/page-header.vue';
import PageContent from '@/common/components/layout/page-content.vue';
import PageSection from '@/common/components/layout/page-section.vue';
import VulnerabilityInfo from '@/common/components/vulnerability/vulnerability-info.vue';
import HttpRequestInfo from '@/common/components/vulnerability/http-request-info.vue';
import DataFlowInfo from '@/common/components/vulnerability/dataflow-info.vue';
import StackTraceInfo from '@/common/components/vulnerability/stack-trace-info.vue';
import VulnerabilityApi from '@/domains/vulnerability/vulnerabilityApi';
import {
	HttpRequest,
	Incident,
	IncidentType,
	Severity,
	Vulnerability,
	VulnerabilityStatus
} from '@/domains/vulnerability/vulnerability.types';
import { mdiBlur, mdiCheck, mdiShieldBugOutline, mdiTrashCan } from '@mdi/js';

export default Vue.extend({
	name: 'VulnerabilitiesDetails',
	components: {
		PageContent,
		PageHeader,
		PageSection,
		VulnerabilityInfo,
		HttpRequestInfo,
		DataFlowInfo,
		StackTraceInfo
	},
	props: {
		vulnerabilityId: { default: null, type: String }
	},
	data() {
		return {
			mdiBlur: mdiBlur,
			mdiTrashCan: mdiTrashCan,
			mdiCheck: mdiCheck,
			mdiShieldBugOutline: mdiShieldBugOutline,
			vulnerability: {} as Vulnerability
		};
	},
	computed: {
		title(): string {
			if (this.vulnerability.id) {
				return `${this.vulnerability.type}: ${this.vulnerability.description}`;
			} else {
				return '';
			}
		},
		iconColor(): string {
			switch (this.vulnerability.severity) {
				case Severity.HIGH:
					return 'red';
				case Severity.MODERATE:
					return 'orange';
				case Severity.LOW:
					return 'grey';
				default:
					return 'grey';
			}
		},
		incidents(): Incident[] | null {
			if (this.vulnerability) {
				return this.vulnerability.incidents;
			}
			return null;
		},
		httpRequests(): (HttpRequest | null)[] {
			if (this.vulnerability && !!this.vulnerability.incidents) {
				return this.vulnerability.incidents.map(i => i.httpRequest).filter(i => typeof i !== typeof undefined);
			}
			return [];
		},
		stackTrace(): string[] | null {
			// show only one stack trace
			if (this.vulnerability && !!this.vulnerability.incidents) {
				return this.vulnerability.incidents[0].stackTrace;
			}
			return null;
		},
		isFixed(): boolean {
			if (this.vulnerability) {
				return this.vulnerability.status === VulnerabilityStatus.FIXED;
			}
			return false;
		},
		isInvalid(): boolean {
			if (this.vulnerability) {
				return this.vulnerability.status === VulnerabilityStatus.INVALID;
			}
			return false;
		},
		isSqlInjection(): boolean {
			const incidents = this.vulnerability.incidents;
			if (typeof incidents !== typeof undefined) {
				return incidents?.filter(i => i.incidentType === IncidentType.SQL_INJECTION).length > 0;
			}
			return false;
		},
		renderHttpInfoBox(): boolean {
			const incidents = this.vulnerability.incidents;
			return incidents?.findIndex(i => typeof i.httpRequest?.method !== typeof undefined) >= 0;
		}
	},
	mounted() {
		this.fetchVulnerability(this.vulnerabilityId);
	},
	methods: {
		async fetchVulnerability(vulnerabilityId: string) {
			this.vulnerability = (await VulnerabilityApi.getVulnerabilityById(vulnerabilityId)).data;
		},
		async markAsFixed() {
			this.vulnerability = (await VulnerabilityApi.flagVulnerabilityAsFixed(this.vulnerabilityId)).data;
		},
		async markAsInvalid() {
			this.vulnerability = (await VulnerabilityApi.flagVulnerabilityAsInvalid(this.vulnerabilityId)).data;
		},
		async deleteVulnerability() {
			await VulnerabilityApi.deleteVulnerability(this.vulnerabilityId);
			this.$router.push('/vulnerabilities');
		}
	}
});
</script>
